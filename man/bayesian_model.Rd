% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesian_model.R
\name{bayesian_model}
\alias{bayesian_model}
\title{Fit a Bayesian Generalized Linear Regression Model (BGLR)}
\usage{
bayesian_model(
  x,
  y,
  iterations_number = 1500,
  burn_in = 500,
  thinning = 5,
  covariance_structure = list(df0 = 5, S0 = NULL, type = "Unstructured"),
  records_weights = NULL,
  response_groups = NULL,
  testing_indices = NULL,
  validate_params = TRUE,
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{(\code{list}) The predictor (independent) variable(s). It is expected a
\code{list} with nested \code{list}'s where each inner \code{list} is named and represents
a predictor effect. Such inner \code{list}'s must have the two names:
\code{x} (\code{matrix}) with the predictor variable that is going to be converted to
\code{numeric} and \code{model} (\code{character(1)}) (case not sensitive) with the type
of model to apply to this predictor term, the available models are
\code{"FIXED"}, \code{"BGBLUP"}, \code{"BRR"}, \code{"Bayes_Lasso"}, \code{"Bayes_A"}, \code{"Bayes_B"}
and \code{"Bayes_C"}. In multivariate models you can only use \code{"FIXED"},
\code{"BGBLUP"} and \code{"BRR"}. \code{"BRR"} by default.}

\item{y}{(\code{data.frame} | \code{vector} | \code{matrix}) The response (dependent)
variable(s). If it is a \code{data.frame} or a \code{matrix} with 2 or more columns,
a multivariate model is assumed, a univariate model otherwise. In
univariate models if \code{y} is \code{character}, \code{logical} or \code{factor} a
categorical response is assumed, numeric otherwise. In multivariate models
all responses are coerced to numeric. \code{y} can contain missing values (\code{NA})
which represent the observations to be used as testing set along the
provided indices in \code{testing_indices} parameter.}

\item{iterations_number}{(\code{numeric(1)}) Number of iterations to fit the
model. 1500 by default.}

\item{burn_in}{(\code{numeric(1)}) Number of items to burn at the beginning of the
model. 500 by default.}

\item{thinning}{(\code{numeric(1)}) Number of items to thin the model. 5 by
default.}

\item{covariance_structure}{(\code{list}) (Only for multivariate models) A named
\code{list} used to define the co-variance matrix for model residuals. This list
must have the fileds \code{type} (\code{character(1)}) (case not sensitive) with one
of the following values \code{"Unstructured"}, \code{"Diagonal"}, \code{"Factor_analytic"}
or \code{"Recursive"}, \code{df0} (\code{numeric(1)}) with the degrees of freedom and \code{S0}
with the covariance matrix of size \verb{t x t}, where \code{t} is the number of
response variables. By default the next \code{list} is used:
\code{list(df0 = 5, S0 = NULL, type = "Unstructured")}.}

\item{records_weights}{(\code{numeric}) (only for univariate models with a numeric
response variables) A vector of weights. If weights are provided the
residual variance of each data-point is set to be proportional to the
inverse of the squared-weight. \code{NULL} by default.}

\item{response_groups}{(\code{factor}) (only for univariate models) A vector of
the same length as \code{y} that associates observations with groups, each group
will have an associated variance component for the error term. \code{NULL} by
default.}

\item{testing_indices}{(\code{numeric}) The records' indices to be used as testing
set along all that contain missing values in \code{y}. \code{NULL} by default.}

\item{validate_params}{(\code{logical(1)}) Should the parameters be validated? It
is not recommended to set this parameter to \code{FALSE} because if something
fails a non meaningful error is going to be thrown. \code{TRUE} by default.}

\item{seed}{(\code{numeric(1)}) A value to be used as internal seed for
reproducible results. \code{NULL} by default.}

\item{verbose}{(\code{logical(1)}) Should the progress information be printed?
\code{TRUE} by default.}
}
\value{
An object of class \code{"BayesianModel"} that inherits from classes
\code{"Model"} and \code{"R6"} with the fields:
\itemize{
\item \code{fitted_model}: An object of class \code{\link[BGLR:BGLR]{BGLR::BGLR()}} with the model.
\item \code{x}: The final \code{list} used to fit the model.
\item \code{y}: The final \code{vector} or \code{matrix} used to fit the model.
\item \code{execution_time}: A \code{difftime} object with the total time taken to tune and
fit the model.
\item \code{removed_rows}: A \code{numeric} vector with the records' indices (in the
provided position) that were deleted and not taken in account in tunning
nor training.
\item \code{removed_x_cols}: A \code{numeric} vector with the columns' indices (in the
provided positions) that were deleted and not taken in account in tunning
nor training.
\item \code{...}: Some other parameters for internal use.
}
}
\description{
\code{bayesian_model()} is a wrapper of the \code{\link[BGLR:BGLR]{BGLR::BGLR()}} and
\code{\link[BGLR:Multitrait]{BGLR::Multitrait()}} functions to fit a Bayesian regresssion model. You can
fit univariate models for numeric and categorical response variables and
multivariate models for numeric responses only.
}
\details{
Since \link{BGLR} functions works a little different than other most common R
packages for machine learning \code{bayesian_model} functions adapts to it. Unlike
other functions, if you want to fit a bayesian model and make some
predictions you have to provide the whole data (for training and testing) and
the records' indices to be used as testing (\code{testing_indices}). All records
with \code{NA} values in \code{y} are considered as part of testing set too.
After fitting the model, the predicted values can be obtained with the
\code{predict} function, with no more parameter than the model, see Examples
section below for more information.
}
\examples{
# Use all default hyperparameters ----------------------------------------------
x <- list(list(x = to_matrix(iris[, -5]), model = "BRR"))
y <- iris$Species
model <- bayesian_model(x, y, testing_indices = c(1:5, 51:55, 101:105))

# Obtain the model's coefficients
coef(model)

# Predict using the fitted model (of the specified testing indices)
predictions <- predict(model)
# Obtain the predicted values
predictions$predicted
# Obtain the predicted probabilities
predictions$probabilities

# Obtain the predict values of custom individuals ------------------------------
x <- list(
  list(x = to_matrix(iris$Species), model = "fixed"),
  list(x = to_matrix(iris[, c(3, 4)]), model = "bayes_a")
)
y <- iris$Sepal.Length
y[c(5, 10, 15, 60, 80, 120, 130)] <- NA
model <- bayesian_model(
  x,
  y,
  iterations_number = 2000,
  burn_in = 500
)

# Predict using the fitted model
predictions <- predict(model)
# Obtain the predicted values
predictions$predicted

# Obtain the Predicted values of custom individuals using the fitted model
predictions <- predict(model, indices = 1:100)
# Obtain the predicted values
predictions$predicted

# Multivariate analysis --------------------------------------------------------
x <- list(list(x = to_matrix(iris[, -c(1, 2)]), model = "fixed"))
y <- iris[, c(1, 2)]
model <- bayesian_model(x, y, iterations_number = 2000)

# Predict using the fitted model
predictions <- predict(model, indices = 1:50)
# Obtain the predicted values of the first response variable
predictions$Sepal.Length$predicted
# Obtain the predicted values of the second response variable
predictions$Sepal.Width$predicted

# Obtain the predictions in a data.frame not in a list
predictions <- predict(model, indices = 1:50, format = "data.frame")
head(predictions)

# Genomic selection ------------------------------------------------------------
data(Maize)

# Data preparation of G
Line <- model.matrix(~ 0 + Line, data = Maize$Pheno)
Env <- model.matrix(~ 0 + Env, data = Maize$Pheno)
# Compute cholesky
Geno <- cholesky(Maize$Geno)
# G matrix
LineGeno <- Line \%*\% Geno

# Identify the model
X <- list(
  Env = list(x = Env, model = "FIXED"),
  LinexGeno = list(x = LineGeno, model = "BRR")
)
y <- Maize$Pheno$Y

# Set seed for reproducible results
set.seed(2022)
folds <- cv_kfold(records_number = nrow(LineGeno), k = 5)

Predictions <- data.frame()

# Model training and predictions
for (i in seq_along(folds)) {
  cat("*** Fold:", i, "***\n")
  fold <- folds[[i]]

  # Model training
  model <- bayesian_model(
    x = X,
    y = y,
    testing_indices = fold$testing,
    iterations_number = 1000,
    burn_in = 500
  )

  # Prediction of testing set
  predictions <- predict(model)

  # Predictions for the i-th fold
  FoldPredictions <- data.frame(
    Fold = i,
    Line = Maize$Pheno$Line[fold$testing],
    Env = Maize$Pheno$Env[fold$testing],
    Observed = y[fold$testing],
    Predicted = predictions$predicted
  )
  Predictions <- rbind(Predictions, FoldPredictions)
}

head(Predictions)
# Compute the summary of all predictions
summaries <- gs_summaries(Predictions)

# Summaries by Line
head(summaries$line)

# Summaries by Environment
summaries$env

# Summaries by Fold
summaries$fold
}
\seealso{
\code{\link[=predict.BayesianModel]{predict.BayesianModel()}}, \code{\link[=coef.Model]{coef.Model()}}

Other models: 
\code{\link{deep_learning}()},
\code{\link{generalized_boosted_machine}()},
\code{\link{generalized_linear_model}()},
\code{\link{mixed_model}()},
\code{\link{partial_least_squares}()},
\code{\link{random_forest}()},
\code{\link{support_vector_machine}()}
}
\concept{models}
