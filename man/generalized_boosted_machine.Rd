% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generalized_boosted_machine.R
\name{generalized_boosted_machine}
\alias{generalized_boosted_machine}
\title{Fit a Generalized Boosted Machine (GBM)}
\usage{
generalized_boosted_machine(
  x,
  y,
  trees_number = 500,
  max_depth = 1,
  node_size = 10,
  shrinkage = 0.1,
  sampled_records_proportion = 0.5,
  tune_type = "Grid_search",
  tune_cv_type = "K_fold",
  tune_folds_number = 5,
  tune_testing_proportion = 0.2,
  tune_folds = NULL,
  tune_loss_function = NULL,
  tune_grid_proportion = 1,
  tune_bayes_samples_number = 10,
  tune_bayes_iterations_number = 10,
  predictors_relationship = NULL,
  validate_params = TRUE,
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{(\code{matrix}) The predictor (independet) variable(s). It must be a
numeric matrix. You can use \code{\link[=to_matrix]{to_matrix()}} function to convert your data to
to a \code{matrix}.}

\item{y}{(\code{data.frame} | \code{vector} | \code{matrix}) The response (dependent)
variable. If it is a \code{data.frame} or a \code{matrix} it must have only one
column. If \code{y} is \code{character}, \code{logical} or \code{factor} a categorical response
is assumed. When the response is categorical with only two classes a binary
distribution is assumed, with more than two classes a multinomial
distribution. When the response variable is numeric with only integers
values greater or equals than zero a poisson distribution is assumed,
gaussian distribution otherwise.}

\item{trees_number}{(\code{numeric}) (\strong{tunable}) Number of trees. This is
equivalent to the number of iterations and the number of basis functions in
the additive expansion. 500 by default.}

\item{max_depth}{(\code{numeric}) (\strong{tunable}) Maximum depth of each tree
(the highest level of variable interactions allowed). A value of 1 implies
an additive model, a value of 2 implies a model with up to 2-way
interactions, etc. 1 by default.}

\item{node_size}{(\code{numeric}) (\strong{tunable}) Also known as \code{n.minobsinnode}.
Minimum number of observations in the terminal nodes of the trees. 10 by
default.}

\item{shrinkage}{(\code{numeric}) (\strong{tunable}) A shrinkage parameter applied to
each tree in the expansion. Also known as the learning rate or step-size
reduction. 0.001 to 0.1 usually work, but a smaller learning rate typically
requires more trees. 0.1 by default.}

\item{sampled_records_proportion}{(\code{numeric}) (\strong{tunable}) Also known as
\code{bag.fraction}. The fraction of the training set observations randomly
selected to propose the next tree in the expansion. This introduces
randomnesses into the model fit. 0.5 by default.}

\item{tune_type}{(\code{character(1)}) (case not sensitive) The type of tuning to
perform. The options are \code{"Grid_search"} and "\code{Bayesian_optimization}".
\code{"Grid_search"} by default.}

\item{tune_cv_type}{(\code{character(1)}) (case not sensitive) The type of cross
validation to tune the model. The options are \code{"K_fold"} and
\code{"Random"}. \code{"K_fold"} by defaul.}

\item{tune_folds_number}{(\code{numeric(1)}) The number of folds to tune each
hyperparameter combination (k in k-fold cross validation). 5 by default.}

\item{tune_testing_proportion}{(\code{numeric(1)}) A number between (0, 1) to
specify the proportion of records to use as validation set when
\code{tune_cv_type} is \code{"Random"}. 0.2 by default.}

\item{tune_folds}{(\code{list}) Custom folds for tuning. It must be a \code{list} of
\code{list}'s where each entry will represent a fold. Each inner \code{list} has to
contain the fields \code{"training"} and \code{"testing"} with numeric vectors of
indices of those entries to be used as training and testing in each fold.
Note that when this parameter is set, \code{tune_cv_type}, \code{tune_folds_number}
and \code{tune_testing_proportion} are ignored. \code{NULL} by default.}

\item{tune_loss_function}{(\code{character(1)}) (case not sensitive) The loss
function to use in tuning. The options are \code{"mse"}, \code{"maape"}, \code{"mae"},
\code{"nrmse"} or \code{"rmse"} when \code{y} is a numeric response variable,
\code{"accuracy"} or \code{"kappa_coeff"} when \code{y} is a categorical response
variable (including binary) and \code{"f1_score"}, \code{"roc_auc"} or \code{"pr_auc"}
when \code{y} is a binary response variable. \code{NULL} by default which uses
\code{"mse"} for numeric variables and \code{"accuracy"} for categorical variables.}

\item{tune_grid_proportion}{(\code{numeric(1)}) Only when \code{tune_type} is
\code{"Grid_search"}, a number between (0, 1] to specify the proportion of
hyperparameters combinations to sample from the grid and evaluate in
tuning (useful when the grid is big). 1 by default (full grid).}

\item{tune_bayes_samples_number}{(\code{numeric(1)}) Only when \code{tune_type} is
\code{"Bayesian_optimization"}, the number of initial random hyperparameters
combinations to evalute before the Bayesian optimization process. 10 by
default.}

\item{tune_bayes_iterations_number}{(\code{numeric(1)}) Only when \code{tune_type} is
\code{"Bayesian_optimization"}, the number of optimization iterations to
evaluate after the initial random samples specified in
\code{tune_bayes_samples_number}. 10 by default.}

\item{predictors_relationship}{(\code{numeric}) Also known as \code{var.monotone}.
A vector with the same length as the number of predictors, indicating which
variables have a monotone increasing (+1), decreasing (-1), or arbitrary
(0) relationship with the outcome. \code{NULL} by default.}

\item{validate_params}{(\code{logical(1)}) Should the parameters be validated? It
is not recommended to set this parameter to \code{FALSE} because if something
fails a non meaningful error is going to be thrown. \code{TRUE} by default.}

\item{seed}{(\code{numeric(1)}) A value to be used as internal seed for
reproducible results. \code{NULL} by default.}

\item{verbose}{(\code{logical(1)}) Should the progress information be printed?
\code{TRUE} by default.}
}
\value{
An object of class \code{"GeneralizedBoostedMachineModel"} that inherits from classes
\code{"Model"} and \code{"R6"} with the fields:
\itemize{
\item \code{fitted_model}: An object of class \code{\link[gbm:gbm.fit]{gbm::gbm.fit()}} with the model.
\item \code{x}: The final \code{matrix} used to fit the model.
\item \code{y}: The final \code{vector} used to fit the model.
\item \code{hyperparams_grid}: A \code{data.frame} with all the computed combinations of
hyperparameters and with one more column called \code{"loss"} with the value of
the loss function for each combination. The data is ordered with the best
combinations at start, sometimes with the lowest values first and other
times with the greatest values first, depending the loss function.
\item \code{best_hyperparams}: A \code{list} with the combination of hyperparameters with
the best loss value (the first row in \code{hyperparams_grid}).
\item \code{execution_time}: A \code{difftime} object with the total time taken to tune and
fit the model.
\item \code{removed_rows}: A \code{numeric} vector with the records' indices (in the
provided position) that were deleted and not taken in account in tunning
nor training.
\item \code{removed_x_cols}: A \code{numeric} vector with the columns' indices (in the
provided positions) that were deleted and not taken in account in tunning
nor training.
\item \code{...}: Some other parameters for internal use.
}
}
\description{
\code{generalized_boosted_machine()} is a wrapper of the \code{\link[gbm:gbm]{gbm::gbm()}} function
with the ability to tune the hyperparameters (grid search) in a simple way.
It fits univariate models for continuous, count, binary and categorical
response variables.

All the parameters marked as (\strong{tunable}) accept a vector of values with
wich the grid is generated for grid search tuning or a list with the min
and max values for bayesian optimization tuning. The returned object contains
a \code{data.frame} with the hyperparameters combinations evaluated. In the end
the best combination of hyperparameters is used to fit the final model, which
is also returned and can be used to make new predictions.
}
\details{
All records with missing values (\code{NA}), either in \code{x} or in \code{y} will be
removed. The positions of the removed records are returned in the
\code{removed_rows} field of the returned object.

\subsection{Tuning}{

The general tuning algorithm works as follows:

\figure{tuning_algorithm.png}{Tuning algorithm}

For grid search tuning, the hyperparameters grid is generated (step one in
the algorithm) with the cartesian product of all the provided values (all the
posible combinations) in all \strong{tunable} parameters. If only one value of
each \strong{tunable} parameter is provided no tuning is done.
\code{tune_grid_proportion} allows you to specify the proportion of all
combinations you want to sample from the full grid and tune them, by default
all combinations are evaluated.

For bayesian optimization tuning, step one in the algorithm works a little
different. At start, \code{tune_bayes_samples_number} different
hyperparameters combinations are generated and evaluated, then
\code{tune_bayes_iterations_number} new hyperparameters combinations are generated
and evaluated iteratively based on the bayesian optimization algorithm, but
this process is equivalent to that described in the general tuninig
algorithm. Note that only the hyperparameters for which the list of min and
max values were provided are tuned and their values fall in the specified
boundaries.
}

In univariate models with a numeric response variable, Mean
Squared Error (\code{\link[=mse]{mse()}}) is used by default as loss function. In univariate
models with a categorical response variable, either binary or with more than
two categories, accuracy (\code{\link[=accuracy]{accuracy()}}) is used by default. You can change
the default loss function used in tuning with the \code{tune_loss_function}
parameter.
}
\examples{
\dontrun{
# Fit with all default parameters
model <- generalized_boosted_machine(to_matrix(iris[, -5]), iris$Species)

# Tune 3 hyperparameters
model <- generalized_boosted_machine(
  to_matrix(iris[, -1]),
  iris$Sepal.Length,
  trees_number = c(100, 200, 300),
  node_size = c(5, 10),
  shrinkage = c(0.001, 0.01, 0.1),
  sampled_records_proportion = c(0.5, 0.75)
)

predictions <- predict(model, iris)
predictions$predicted

# See the whole grid
model$hyperparams_grid
}

}
\seealso{
\code{\link[=predict.Model]{predict.Model()}}

Other models: 
\code{\link{bayesian_model}()},
\code{\link{deep_learning}()},
\code{\link{generalized_linear_model}()},
\code{\link{partial_least_squares}()},
\code{\link{random_forest}()},
\code{\link{support_vector_machine}()}
}
\concept{models}
